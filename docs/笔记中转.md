## 贪心算法

### 主持人调度（二）

- 描述

  有n个活动即将举办，每个活动都有开始时间和结束时间，第i个活动开始时间是start~i~,第i个活动的结束时间是end~i~,举办某个活动就需要为该活动准备一个活动主持人。

  一个活动主持人在同一时间只能参加一个活动，并且活动主持人需要全程参与活动，换句话说，一个主持人参与了第i个活动，那么该主持人在（start~i~,end~i~）这个时间段不能参加其他任何活动。求成功举办这n个活动，最少需要多少名主持人。

  数据范围：1≤n≤10^5^,-2^32^ <= start~i~ <= end~i~ <= 2^31^-1

  复杂度要求：时间复杂度O(nlogn),空间复杂度O(n)

  ```java
  输入：2,[[1,2],[2,3]]
  返回值：1
  说明：只需要一个主持人就能成功举办这两个活动      
  ```

- 贪心思想

  - 首先建立两个数组分别存储开始时间（记为start）和结束时间（记为end）。
  - 然后分别对start和end数组进行排序。(结束时间依次往后面推)
  - 接着遍历start数组，判断当前开始时间是否大于等于最小的结束时间，如果是，则说明当前主持人就可以搞定（对应当前最小的结束时间的那个活动）；如果否，则需要新增一个主持人，并将end数组下标后移（表示对应的活动已经有人主持）。

- 代码

  ```java
  import java.util.*;
  
  public class Solution {
      /**
       * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
       * 计算成功举办活动需要多少名主持人
       * @param n int整型 有n个活动
       * @param startEnd int整型二维数组 startEnd[i][0]用于表示第i个活动的开始时间，startEnd[i][1]表示第i个活动的结束时间
       * @return int整型
       */
      public int minmumNumberOfHost (int n, int[][] startEnd) {
          //初始化两个数组，分别记录开始时间和结束时间
          int[] start=new int[n];
          int[] end=new int[n];
  
          //将活动的开始和结束时间赋值道start和end数组
          for(int i=0;i<n;i++){
              start[i]=startEnd[i][0];
              end[i]=startEnd[i][1];
          }
  
          //按从小到大的顺序对start和end数组排序
          Arrays.sort(start);
          Arrays.sort(end);
  
          int res=0,index=0;
          for(int i=0;i<n;i++){
              //如果大于等于当前最小的结束时间，说明当前主持人可以搞定
              if(start[i]>=end[index]){
                  index++;
              }
              //否则，需要新增主持人
              else{
                  res++;
              }
          }
  
          return res;
  
      }
  }
  ```

### 跳跃游戏

- 描述

  给定一个非负整数数组nums，你最初位于数组的第一个下标，数组中的每个元素代表你在该位置可以跳跃的最大长度，判断你是否能够到达最后一个下标。

  ```java
  输入：nums = [2,3,1,1,4]
  输出：true
  解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。	
  
  输入：nums = [3,2,1,0,4]
  输出：false
  解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。
  
  ```

- 思路（贪心思想）

  我们可以用贪心的方法解决这个问题。

  设想一下，对于数组中的任意一个位置 y，我们如何判断它是否可以到达？根据题目的描述，只要存在一个位置 xx，它本身可以到达，并且它跳跃的最大长度为 x+nums[x]，这个值大于等于 y，即 x+nums[x]≥y，那么位置 y 也可以到达。

  换句话说，对于每一个可以到达的位置 x，它使得x+1,x+2,⋯,x+nums[x] 这些连续的位置都可以到达。

  这样以来，我们依次遍历数组中的每一个位置，并实时维护 最远可以到达的位置。对于当前遍历到的位置 x，如果它在 最远可以到达的位置 的范围内，那么我们就可以从起点通过若干次跳跃到达该位置，因此我们可以用 x+nums[x] 更新 最远可以到达的位置。

  在遍历的过程中，如果 最远可以到达的位置 大于等于数组中的最后一个位置，那就说明最后一个位置可达，我们就可以直接返回 True 作为答案。反之，如果在遍历结束后，最后一个位置仍然不可达，我们就返回 False 作为答案。

- 代码

  ```java
  public class Solution {
      public boolean canJump(int[] nums) {
          int n = nums.length;
          int rightmost = 0;
          for (int i = 0; i < n; ++i) {
              if (i <= rightmost) {
                  //维护可以跳到的最大位置
                  rightmost = Math.max(rightmost, i + nums[i]);
                  if (rightmost >= n - 1) {
                      return true;
                  }
              }
          }
          return false;
      }
  }
  ```

## 双指针

### 盛最多水的容器

- 描述

  给定一个长度为n的整数数组height，有n条垂线，第i条线的两个端点是（i,0）和（i,height[i]）。找出其中的两条线，使得它们与x轴共同构成的容器可以容纳最多的水。

  ![img](Datastructureandalgorithm.assets/question_11.jpg)

```java
输入：[1,8,6,2,5,4,8,3,7]
输出：49 
解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。
```

- 思路（双指针）

  设两指针 i , j ，指向的水槽板高度分别为 h[i] , h[j] ，此状态下水槽面积为 S(i,j) 。由于可容纳水的高度由两板中的短板决定，因此可得如下面积公式 ：

![Picture0.png](Datastructureandalgorithm.assets/1628780627-VtSmcP-Picture0.png)

在每个状态下，无论长板或短板向中间收窄一格，都会导致水槽 底边宽度 -1−1 变短：

- 若向内 移动短板 ，水槽的短板 min(h[i], h[j])min(h[i],h[j]) 可能变大，因此下个水槽的面积 可能增大 。

- 若向内 移动长板 ，水槽的短板 min(h[i], h[j])min(h[i],h[j]) 不变或变小，因此下个水槽的面积 一定变小 。因此，初始化双指针分列水槽左右两端，循环每轮将**短板向内移动一格**，并更新面积最大值，直到两指针相遇时跳出；即可获得最大面积。

- 代码

  ```java
  class Solution {
      public int maxArea(int[] height) {
          int i = 0, j = height.length - 1, res = 0;
          while(i < j) {
              res = height[i] < height[j] ? 
                  Math.max(res, (j - i) * height[i++]): 
                  Math.max(res, (j - i) * height[j--]); 
          }
          return res;
      }
  }
  ```

### 合并两个有序的数组

- 描述

  给出一个有序的整数数组 A 和有序的整数数组 B ，请将数组 B 合并到数组 A 中，变成一个有序的升序数组数据范围：1000≤*n*,*m*≤100，|A_i| <=100， |B_i| <= 100

  - 注意：
    保证 A 数组有足够的空间存放 B 数组的元素， A 和 B 中初始的元素数目分别为 m 和 n，A的数组空间大小为 m+n

    不要返回合并的数组，将数组 B 的数据合并到 A 里面就好了，且后台会自动将合并后的数组 A 的内容打印出来，所以也不需要自己打印

    A 数组在[0,m-1]的范围也是有序的

  ```java
  输入：[4,5,6],[1,2,3]
  返回值：[1,2,3,4,5,6]
  说明：
  A数组为[4,5,6]，B数组为[1,2,3]，后台程序会预先将A扩容为[4,5,6,0,0,0]，B还是为[1,2,3]，m=3，n=3，传入到函数merge里面，然后请同学完成merge函数，将B的数据合并A里面，最后后台程序输出A数组    
  ```

  

- 思路

  ![alt](Datastructureandalgorithm.assets/262712F1AAAB9043384442160A7FA6E8.gif)

- 代码

  ```java
  import java.util.*;
  public class Solution {
      public void merge(int A[], int m, int B[], int n) {
          //指向数组A的结尾
          int i = m - 1; 
          //指向数组B的结尾
          int j = n - 1; 
          //指向数组A空间的结尾处
          int k = m + n - 1; 
          //从两个数组最大的元素开始，直到某一个数组遍历完
          while(i >= 0 && j >= 0){ 
              //将较大的元素放到最后
              if(A[i] > B[j]) 
                  A[k--] = A[i--];
              else
                  A[k--] = B[j--];
          }
          //数组A遍历完了，数组B还有，则还需要添加到数组A前面
          if(i < 0){ 
              while(j >= 0)
                  A[k--] = B[j--];
          } 
          //数组B遍历完了，数组A前面正好有，不用再添加
      }
  }
  
  ```

### 合并区间

- 描述

  给出一组区间，请合并所有重叠的区间。

  请保证合并后的区间按区间起点升序排列。

  数据范围：区间组数 0≤*n*≤2×10^5^，区间内的值都满足0≤val≤2×10^5^

  要求：空间复杂度 O*(*n*)，时间复杂度 O(nlogn)

  进阶：空间复杂度 O(val)，时间复杂度O(val)

  ```java
  输入：[[10,30],[20,60],[80,100],[150,180]]
  返回值：[[10,60],[80,100],[150,180]]
  ```

- 思路

  - 对左边界排序，

  - 如果下一个区间的左边界在前一个的有边界内，考虑是否要更新边界，

  - 如果下一个区间的左边界在前一个的有边界外，说明区间无法合并，开始计算下一个区间

- 代码

  ```java
      public ArrayList<Interval> merge(ArrayList<Interval> intervals) {
          ArrayList<Interval> res = new ArrayList<>();
          Collections.sort(intervals,(a,b)->a.start-b.start);
          int len = intervals.size();
          int i = 0;
          while (i < len) {
              //初始化小区间
              int left = intervals.get(i).start;
              int right = intervals.get(i).end;
              //不断找到，后面区间的start位置与当前区间交叉，考虑更新最大end
              while (i < len-1 && intervals.get(i+1).start <= right) {
                  right = Math.max(right,intervals.get(i+1).end);
                  i++;
              }
              //更新完后,加入res，继续循环找到下一个区间
              res.add(new Interval(left,right));
              i++;
          }
          return res;
      }
  ```

  
